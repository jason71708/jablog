---
title: 'Counting Sort'
tags:
  - algorithms
keywords: [algorithms, 演算法]
---

Counting Sort 是以**數字為基礎**的排序演算法，其需要定義**最大範圍值**，作為排序用，整體算法較簡單且速度較快，缺點就是排序元素需要確定在最大範圍值內且需要額外空間儲存做運算。

## Step 1 - Counting How Many Times Each Element Occurs

假設現在有個待排序的陣列 (Input Array: IArray)： `[4, 4, 6, 1, 3, 0, 2]` ，並且定義此算法最大範圍值為 `6` (以下簡稱最大值) 。

:::tip
通常數字可能的範圍會訂在 0 ~ 最大值 之間的**整數**，可根據實際需求做調整，整體概念與流程還是一樣的。
:::

最大值為 `6` ，建立一個陣列 (Counting Array: CArray)有 6 + 1 個元素，暫都先設 `0` ： `[0, 0, 0, 0, 0, 0, 0]` 。

所以 CArray 有 7 個位置，每個位置的 Index 代表 0 ~ 6 的數字。

接著算各個元素出現的次數： `[1, 1, 1, 1, 2, 0, 1]`

上述結果可以看到 Index 5 代表的數字 5 沒有出現過，所以記 `0` 。

Index 4 代表的數字 4 出現過兩次，所以記 `2` 。

## Step 2 - Sorting & Output

接著建立一個空陣列 (Output Array: OArray) ： `[]` 。

根據 CArray 的數值依序加入 OArray 中：

1. `[1, 1, 1, 1, 2, 0, 1]`： `0` 有出現過 1 次，將其加入 OArray 中 -> `[0]` ，並且將 `0` 計次減 1 。
2. `[0, 1, 1, 1, 2, 0, 1]`： `0` 目前計次為 0 ，換下個， `1` 有出現過 1 次，將其加入 OArray 中 -> `[0, 1]` ，並且將 `1` 計次減 1 。
3. `[0, 0, 1, 1, 2, 0, 1]`： `1` 目前計次為 0 ，換下個， `2` 有出現過 1 次，將其加入 OArray 中 -> `[0, 1, 2]` ，並且將 `2` 計次減 1 。
4. `[0, 0, 0, 1, 2, 0, 1]`： `2` 目前計次為 0 ，換下個， `3` 有出現過 1 次，將其加入 OArray 中 -> `[0, 1, 2, 3]` ，並且將 `3` 計次減 1 。
5. `[0, 0, 0, 0, 2, 0, 1]`： `3` 目前計次為 0 ，換下個， `4` 有出現過 2 次，將其加入 OArray 中 -> `[0, 1, 2, 3, 4]` ，並且將 `4` 計次減 1 。
6. `[0, 0, 0, 0, 1, 0, 1]`： `4` 有出現過 1 次，將其加入 OArray 中 -> `[0, 1, 2, 3, 4, 4]` ，並且將 `4` 計次減 1 。
7. `[0, 0, 0, 0, 0, 0, 1]`： `4` 與 `5` 計次都為 0 。
8. `[0, 0, 0, 0, 0, 0, 1]`： `6` 有出現過 1 次，將其加入 OArray 中 -> `[0, 1, 2, 3, 4, 4, 6]` ，並且將 `6` 計次減 1 。
9. 沒有 Index 7 ，超過最大範圍值，結束。

其輸出結果為 `[0, 1, 2, 3, 4, 4, 6]` 。
